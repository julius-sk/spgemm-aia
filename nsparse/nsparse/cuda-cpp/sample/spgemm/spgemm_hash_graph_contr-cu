#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

#include <math.h>
#include <random>
#include <cuda.h>
#include <algorithm>
#include <helper_cuda.h>
#include <cusparse_v2.h>

#include <nsparse.hpp>
#include <CSR.hpp>
#include <SpGEMM.hpp>
#include <HashSpGEMM_volta_graph_contr.hpp>

typedef int IT;
#ifdef FLOAT
typedef float VT;
#else
typedef double VT;
#endif

template <typename IT, typename VT>
CSR<IT, VT> generateRandomContractionMatrix(const CSR<IT, VT>& A, double contraction_ratio) {
    IT original_nodes = A.nrow;
    IT contracted_nodes = std::max(IT(1), IT(std::round(contraction_ratio * original_nodes)));
   std::cout  << "contracted nodes number is  "<< contracted_nodes<< std::endl;
    CSR<IT, VT> S;
    S.nrow = contracted_nodes;
    S.ncolumn = original_nodes;
    S.nnz = original_nodes;

    S.rpt = new IT[contracted_nodes + 1]();
    S.colids = new IT[original_nodes];
    S.values = new VT[original_nodes];

    // Generate random labels for each original node
    IT* labels = new IT[original_nodes];
    std::srand(std::time(nullptr));
    for (IT i = 0; i < original_nodes; ++i) {
        labels[i] = std::rand() % contracted_nodes;
    }

    // Create the CSR format of S
    for (IT i = 0; i < original_nodes; ++i) {
        S.colids[i] = i;
        S.values[i] = 1;
        S.rpt[labels[i] + 1]++;
    }

    // Compute cumulative sum for rpt
    for (IT i = 1; i <= contracted_nodes; ++i) {
        S.rpt[i] += S.rpt[i-1];
    }

    delete[] labels;
    return S;
}

template <typename IT, typename VT>
CSR<IT, VT> transposeContractionMatrix(const CSR<IT, VT>& S) {
    CSR<IT, VT> St;
    St.nrow = S.ncolumn;
    St.ncolumn = S.nrow;
    St.nnz = S.nnz;

    St.rpt = new IT[St.nrow + 1]();
    St.colids = new IT[St.nnz];
    St.values = new VT[St.nnz];

    // Step 1: Count the number of non-zeros in each column of S (row of St)
    for (IT i = 0; i < S.nnz; ++i) {
        St.rpt[S.colids[i] + 1]++;
    }

    // Step 2: Set up the row pointers for St
    for (IT i = 1; i <= St.nrow; ++i) {
        St.rpt[i] += St.rpt[i-1];
    }

    // Step 3: Fill in the column indices and values for St
    IT* current_pos = new IT[St.nrow]();
    for (IT i = 0; i < S.nrow; ++i) {
        for (IT j = S.rpt[i]; j < S.rpt[i + 1]; ++j) {
            IT col = S.colids[j];
            IT pos = St.rpt[col] + current_pos[col];
            St.colids[pos] = i;
            St.values[pos] = S.values[j];
            current_pos[col]++;
        }
    }

    delete[] current_pos;
    return St;
}

template <class idType, class valType>
void graph_contract(CSR<idType, valType>& a)
{
    idType i;
    long long int flop_count1;
    long long int flop_count2;
    float total_AIA_time_1;
    float total_AIA_time_2;
    cudaEvent_t event[2];
    float msec, ave_msec, flops;
  
    for (i = 0; i < 2; i++) {
        cudaEventCreate(&(event[i]));
    }
  
    /* Generate contraction matrix and its transpose */
    double contraction_ratio = 0.5;  // Contract to approximately 50% of original size
    CSR<idType, valType> b = generateRandomContractionMatrix(a, contraction_ratio);

    CSR<idType, valType> d = transposeContractionMatrix(b);

    CSR<idType, valType> c, e;

    /* Memcpy A and B from Host to Device */
    a.memcpyHtD();
    b.memcpyHtD();
    d.memcpyHtD();

    //print_csr_matrix(b, "b(Result)");
    //print_csr_matrix(d, "d(Result)");
    /* Count flop of SpGEMM computation */
    get_spgemm_flop(b, a, flop_count1);
    

    /* Execution of SpGEMM on Device */
    //ave_msec = 0;
    // for (i = 0; i < SpGEMM_TRI_NUM; i++) {
    //     if (i > 0) {
    //         c.release_csr();
    //         e.release_csr();
    //     }
        cudaEventRecord(event[0], 0);
        total_AIA_time_1=SpGEMM_Hash(b, a, c);
        total_AIA_time_2=SpGEMM_Hash(c, d, e);
        cudaEventRecord(event[1], 0);
        cudaDeviceSynchronize();
        cudaEventElapsedTime(&msec, event[0], event[1]);
        
        // if (i > 0) {
        //     ave_msec += msec;
        // }
    //}
    //ave_msec /= SpGEMM_TRI_NUM - 1;
    get_spgemm_flop(c, d, flop_count2);  // Add flops for second SpGEMM
    flops = (float)(flop_count1+flop_count2) / 1000 / 1000 / (msec-total_AIA_time_1-total_AIA_time_2);
    printf("Graph Contraction using CSR format (Hash): %f[GFLOPS], %f[ms]\n", flops, (msec-total_AIA_time_1-total_AIA_time_2));

    c.memcpyDtH();
    e.memcpyDtH();
    
    b.release_csr();
    c.release_csr();
    d.release_csr();
    e.release_csr();

    for (i = 0; i < 2; i++) {
        cudaEventDestroy(event[i]);
    }
}

/*Main Function*/
int main(int argc, char *argv[])
{
    CSR<IT, VT> a;

    /* Set CSR reading from MM file or generating random matrix */
    cout << "Initialize Matrix A" << endl;
    cout << "Read matrix data from " << argv[1] << endl;
    a.init_data_from_mtx(argv[1]);
    a.set_all_nnz_to_one();
    /* Execution of Graph Contraction on GPU */
    graph_contract(a);

    a.release_cpu_csr();
    return 0;
}